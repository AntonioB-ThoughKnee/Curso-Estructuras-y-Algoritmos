// #include "include/Arbol.cpp" NOT .cpp
//=====  
// #include "../include/HMIHDConContador.h"
// #include "../include/HMIHDConPtrPadreOptimizado.h"
#include "../include/HMIHDConPtrPadreyHI.h"

//carlos.Sanchezblanco@ucr.ac.cr
#include <vector>
#include <memory>
#include <iostream>

void test(unique_ptr<int>* p)
{
  unique_ptr<int>* tmp = p;
  cout << "Test printing " << **tmp << endl;
}

void wat(unique_ptr<int>& p)
{
  int* tmp = p.get();
}

Arbol* buscarEtiqueta(int etiqueta, Arbol* A)
{
  Arbol* tmp;
  vector<Arbol*> auxiliar;
  auxiliar.push_back(A->Raiz());
  int i = 0;
  while(i < auxiliar.size())
  {
    tmp = auxiliar[i];
    i++;
    if(tmp->Etiqueta(tmp) == etiqueta) { return tmp; }
    tmp = tmp->HMI(tmp);
    while(tmp != nullptr)
    {
      auxiliar.push_back(tmp);
      tmp = tmp->HD(tmp);
    }
  }

  return nullptr;

}

int main()
{
Arbol* iko = new Arbol();

iko->ponerRaiz(10)
  .agregarHijo(iko->Raiz(), 2)
  ->agregarHijo(iko->Raiz(), 3);
Arbol* root = iko->Raiz();
  
Arbol* level3 = 
  iko->agregarHijo(iko->HMI(iko->Raiz()), 4)
    ->agregarHijo(iko->HMI(iko->Raiz()), 5)
    ->agregarHijoMasDerecho(iko->Raiz(), 6)
    ->agregarHijoMasDerecho(iko->Raiz(), 7);
    
iko->agregarHijo(level3, 8);

Arbol* father = iko->Padre(level3);

//===========================  TESTING

unique_ptr<int> Uptr = make_unique<int>(56);
test(&Uptr);
cout << "Printing the value of good ol Uptr " << *Uptr << endl;
wat(Uptr);

shared_ptr<int> Smptr = make_shared<int>(25);
cout << "shared pointer = " << *Smptr << endl;
{
  shared_ptr<int> ptr = Smptr;
  cout << "shared pointer = " << *Smptr << endl;
  ptr = nullptr;
  Smptr = nullptr;
  
}

//=====  

// iko->borrarHoja(iko->HMI(level3)); //Falta que funcione correctamente el borrar hoja
int c = iko->numNodos();

Arbol* test = buscarEtiqueta(7, iko);

return 0;
}
